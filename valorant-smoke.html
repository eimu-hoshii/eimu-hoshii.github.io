<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- iOS PWA設定 -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="SMOKE GUIDE">

    <title>VALORANT SMOKE GUIDE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        .touch-action-none { touch-action: none; }
        
        .app-container {
            height: 100vh;
            height: 100dvh;
        }

        /* マップ表示エリア */
        .map-viewport {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #0f172a;
            position: relative;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .map-viewport:active { cursor: grabbing; }

        /* 画像変形レイヤー */
        #mapTransformLayer {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            will-change: transform;
            transform-origin: center center;
            padding: 20px; /* 端に少し余白を持たせる */
        }

        /* マップ画像: 画面内に収まるように制限 */
        #mapImage {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
            pointer-events: none;
            display: block;
        }

        .pt-safe { padding-top: env(safe-area-inset-top); }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
    </style>
</head>
<body class="bg-slate-900 text-white font-sans overflow-hidden select-none">

    <div class="app-container flex flex-col">

        <!-- ========================================== -->
        <!-- ヘッダーエリア (操作系を集約) -->
        <!-- ========================================== -->
        <header class="flex-none bg-slate-800/95 backdrop-blur-md border-b border-slate-700 px-4 pt-safe pb-3 z-30 shadow-md flex flex-col gap-3">
            
            <!-- 上段: ロゴとマップ選択 -->
            <div class="h-[50px] flex items-center justify-between gap-3 mt-2">
                <!-- ロゴ (PCのみ) -->
                <div class="flex items-center gap-2 flex-shrink-0">
                    <div class="bg-red-500/10 p-1.5 rounded-lg border border-red-500/20">
                        <i data-lucide="map" class="w-5 h-5 text-red-500"></i>
                    </div>
                    <h1 class="font-bold text-lg tracking-wider hidden sm:block bg-gradient-to-r from-white to-slate-400 bg-clip-text text-transparent">SMOKE GUIDE</h1>
                </div>

                <!-- スマホ用 マップ選択 -->
                <div class="flex-1 md:hidden">
                    <div class="relative w-full">
                        <select id="mobileMapSelect" class="w-full bg-slate-900 text-white font-bold border border-slate-600 rounded-lg py-2 pl-3 pr-10 appearance-none focus:outline-none focus:border-red-500 transition-colors shadow-inner text-sm truncate">
                            <!-- JSで生成 -->
                        </select>
                        <div class="absolute inset-y-0 right-0 flex items-center px-3 pointer-events-none text-slate-400">
                            <i data-lucide="chevron-down" class="w-4 h-4"></i>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 下段: 攻守切り替えスイッチ (ここに移動) -->
            <div class="w-full">
                <div class="bg-slate-900/50 p-1 rounded-lg border border-slate-700 shadow-inner flex relative h-10">
                    <div id="switchBg" class="absolute top-1 bottom-1 w-[calc(50%-4px)] bg-red-500 rounded-md transition-all duration-300 ease-out shadow-md left-1"></div>
                    
                    <button onclick="setSide('ATTACK')" id="btnAttack" class="relative flex-1 rounded-md text-xs font-bold flex items-center justify-center gap-2 z-10 transition-colors text-white">
                        <i data-lucide="sword" class="w-3 h-3"></i> ATTACK
                    </button>
                    <button onclick="setSide('DEFENSE')" id="btnDefense" class="relative flex-1 rounded-md text-xs font-bold flex items-center justify-center gap-2 z-10 transition-colors text-slate-400">
                        <i data-lucide="shield" class="w-3 h-3"></i> DEFENSE
                    </button>
                </div>
            </div>

        </header>

        <div class="flex flex-1 overflow-hidden relative">
            
            <!-- PC用 サイドバー -->
            <aside class="hidden md:flex flex-col w-64 bg-slate-800/95 backdrop-blur border-r border-slate-700 z-20 shadow-xl h-full">
                <div class="p-4 border-b border-slate-700">
                    <h2 class="text-xs font-bold text-slate-400 uppercase tracking-widest flex items-center gap-2">
                        <i data-lucide="crosshair" class="w-3 h-3"></i> Select Map
                    </h2>
                </div>
                <div class="flex-1 overflow-y-auto p-2 pb-20">
                    <div id="pcMapList" class="space-y-1">
                        <!-- JSで生成 -->
                    </div>
                </div>
            </aside>
            
            <!-- メインコンテンツ -->
            <main class="flex-1 flex flex-col relative w-full h-full bg-slate-900">
                
                <!-- マップビューポート -->
                <div id="viewport" class="map-viewport touch-action-none">
                    <div id="mapTransformLayer">
                        <!-- max-width/height: 100% で画面内に収める -->
                        <img id="mapImage" src="" alt="Map Setup" class="shadow-2xl transition-opacity duration-300 opacity-0">
                    </div>
                    
                    <!-- ロード中 -->
                    <div id="loading" class="absolute inset-0 flex flex-col items-center justify-center bg-slate-900 z-10 pointer-events-none">
                        <div class="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-red-500 mb-3"></div>
                        <span class="text-xs text-slate-400 font-mono animate-pulse">LOADING...</span>
                    </div>
                </div>

                <!-- ズームコントロール (右下固定) -->
                <div class="absolute bottom-6 right-4 flex flex-col gap-2 pointer-events-auto pb-safe">
                    <button onclick="handleZoomIn()" class="w-10 h-10 bg-slate-800/90 backdrop-blur border border-slate-600 rounded-lg flex items-center justify-center text-white shadow-lg active:bg-slate-700 active:scale-95 transition-all">
                        <i data-lucide="plus" class="w-5 h-5"></i>
                    </button>
                    <button onclick="handleZoomOut()" class="w-10 h-10 bg-slate-800/90 backdrop-blur border border-slate-600 rounded-lg flex items-center justify-center text-white shadow-lg active:bg-slate-700 active:scale-95 transition-all">
                        <i data-lucide="minus" class="w-5 h-5"></i>
                    </button>
                    <button onclick="resetView()" class="w-10 h-10 bg-slate-800/90 backdrop-blur border border-slate-600 rounded-lg flex items-center justify-center text-white shadow-lg active:bg-slate-700 active:scale-95 transition-all">
                        <i data-lucide="rotate-ccw" class="w-4 h-4"></i>
                    </button>
                </div>

            </main>
        </div>
    </div>

    <script>
        const MAP_DATA = {
            Ascent: { id: "ascent", name: "アセント", attackUrl: "https://i.imgur.com/F7iGqwg.png", defenseUrl: "https://i.imgur.com/fUmWl7X.png" },
            Bind: { id: "bind", name: "バインド", attackUrl: "https://i.imgur.com/rhA4cTV.png", defenseUrl: "https://i.imgur.com/ymzMmix.png" },
            Haven: { id: "haven", name: "ヘイヴン", attackUrl: "https://i.imgur.com/prhVQyX.png", defenseUrl: "https://i.imgur.com/kMZ8Lw8.png" },
            Split: { id: "split", name: "スプリット", attackUrl: "https://i.imgur.com/tXtzM92.png", defenseUrl: "https://i.imgur.com/05kssln.png" },
            Lotus: { id: "lotus", name: "ロータス", attackUrl: "https://i.imgur.com/qTmCQnn.png", defenseUrl: "https://i.imgur.com/Ip4KFDJ.png" },
            Sunset: { id: "sunset", name: "サンセット", attackUrl: "https://i.imgur.com/WwTsgbw.png", defenseUrl: "https://i.imgur.com/SUeEWrh.png" },
            Pearl: { id: "pearl", name: "パール", attackUrl: "https://i.imgur.com/3B9STc7.png", defenseUrl: "https://i.imgur.com/J61iybE.png" },
            Fracture: { id: "fracture", name: "フラクチャー", attackUrl: "https://i.imgur.com/yVcX6R8.png", defenseUrl: "https://i.imgur.com/XikMFT9.png" },
            Breeze: { id: "breeze", name: "ブリーズ", attackUrl: "https://i.imgur.com/B5zbMRA.png", defenseUrl: "https://i.imgur.com/EkF2goF.png" },
            Icebox: { id: "icebox", name: "アイスボックス", attackUrl: "https://i.imgur.com/tLamk9u.png", defenseUrl: "https://i.imgur.com/OuOk6zK.png" },
            Abyss: { id: "abyss", name: "アビス", attackUrl: "https://i.imgur.com/Hb9DnB7.png", defenseUrl: "https://i.imgur.com/xEHdUeF.png" }
        };

        const sortedMapKeys = Object.keys(MAP_DATA).sort((a, b) => MAP_DATA[a].name.localeCompare(MAP_DATA[b].name, 'ja'));
        let currentMap = sortedMapKeys[0];
        let currentSide = 'ATTACK';
        
        let scale = 1, pX = 0, pY = 0;
        let isDragging = false, startX, startY;
        const MIN_SCALE = 1, MAX_SCALE = 4;
        let initialPinchDistance = 0, initialScale = 1, lastTapTime = 0;

        const elements = {
            pcMapList: document.getElementById('pcMapList'),
            mobileMapSelect: document.getElementById('mobileMapSelect'),
            mapImage: document.getElementById('mapImage'),
            layer: document.getElementById('mapTransformLayer'),
            viewport: document.getElementById('viewport'),
            btnAttack: document.getElementById('btnAttack'),
            btnDefense: document.getElementById('btnDefense'),
            switchBg: document.getElementById('switchBg'),
            loading: document.getElementById('loading')
        };

        function init() {
            renderMapSelectors();
            updateDisplay();
            setupInteractions();
            lucide.createIcons();

            elements.mobileMapSelect.addEventListener('change', (e) => {
                currentMap = e.target.value;
                updateDisplay();
                renderMapSelectors();
            });
        }

        function renderMapSelectors() {
            // PC
            elements.pcMapList.innerHTML = '';
            sortedMapKeys.forEach(key => {
                const map = MAP_DATA[key];
                const isActive = key === currentMap;
                const btn = document.createElement('button');
                btn.className = `w-full text-left px-4 py-3 rounded-lg text-sm font-medium transition-all flex items-center justify-between mb-1 ${
                    isActive ? 'bg-red-500/10 text-red-400 border-l-2 border-red-500' : 'text-slate-400 hover:bg-slate-700'
                }`;
                btn.innerHTML = `<span>${map.name}</span>${isActive ? '<i data-lucide="chevron-right" class="w-4 h-4"></i>' : ''}`;
                btn.onclick = () => { currentMap = key; updateDisplay(); renderMapSelectors(); };
                elements.pcMapList.appendChild(btn);
            });
            lucide.createIcons();

            // Mobile
            elements.mobileMapSelect.innerHTML = '';
            sortedMapKeys.forEach(key => {
                const map = MAP_DATA[key];
                const option = document.createElement('option');
                option.value = key;
                option.textContent = map.name;
                if (key === currentMap) option.selected = true;
                elements.mobileMapSelect.appendChild(option);
            });
        }

        function updateDisplay() {
            const map = MAP_DATA[currentMap];
            const url = currentSide === 'ATTACK' ? map.attackUrl : map.defenseUrl;

            if (currentSide === 'ATTACK') {
                elements.switchBg.style.transform = 'translateX(0)';
                elements.switchBg.className = "absolute top-1 bottom-1 w-[calc(50%-4px)] bg-red-500 rounded-md transition-all duration-300 ease-out shadow-md left-1";
                elements.btnAttack.classList.replace('text-slate-400', 'text-white');
                elements.btnDefense.classList.replace('text-white', 'text-slate-400');
            } else {
                elements.switchBg.style.transform = 'translateX(100%) translateX(8px)';
                elements.switchBg.className = "absolute top-1 bottom-1 w-[calc(50%-4px)] bg-teal-600 rounded-md transition-all duration-300 ease-out shadow-md left-0";
                elements.btnAttack.classList.replace('text-white', 'text-slate-400');
                elements.btnDefense.classList.replace('text-slate-400', 'text-white');
            }

            elements.loading.style.display = 'flex';
            elements.mapImage.style.opacity = '0';
            resetView();

            const img = new Image();
            img.onload = () => {
                elements.mapImage.src = url;
                elements.loading.style.display = 'none';
                elements.mapImage.style.opacity = '1';
            };
            img.onerror = () => {
                elements.loading.style.display = 'none';
                elements.mapImage.src = "https://placehold.co/800x600/1e293b/94a3b8?text=No+Image";
                elements.mapImage.style.opacity = '1';
            };
            img.src = url;
        }

        window.setSide = (side) => { if (currentSide !== side) { currentSide = side; updateDisplay(); } };

        function applyTransform() {
            elements.layer.style.transform = `translate(${pX}px, ${pY}px) scale(${scale})`;
        }
        window.handleZoomIn = () => { scale = Math.min(scale + 0.5, MAX_SCALE); applyTransform(); };
        window.handleZoomOut = () => { 
            scale = Math.max(scale - 0.5, MIN_SCALE); 
            if (scale === MIN_SCALE) { pX=0; pY=0; }
            applyTransform(); 
        };
        window.resetView = () => { scale = 1; pX = 0; pY = 0; applyTransform(); };

        function setupInteractions() {
            const vp = elements.viewport;
            
            vp.addEventListener('mousedown', e => {
                if (scale === 1) return;
                isDragging = true;
                startX = e.clientX - pX;
                startY = e.clientY - pY;
                vp.style.cursor = 'grabbing';
            });
            window.addEventListener('mousemove', e => {
                if (!isDragging) return;
                e.preventDefault();
                pX = e.clientX - startX;
                pY = e.clientY - startY;
                requestAnimationFrame(applyTransform);
            });
            window.addEventListener('mouseup', () => { isDragging = false; vp.style.cursor = scale > 1 ? 'grab' : 'default'; });
            
            vp.addEventListener('wheel', e => {
                e.preventDefault();
                const delta = -Math.sign(e.deltaY) * 0.2;
                const newScale = Math.min(Math.max(scale + delta, MIN_SCALE), MAX_SCALE);
                if (newScale !== scale) {
                    scale = newScale;
                    if(scale === MIN_SCALE) { pX=0; pY=0; }
                    applyTransform();
                }
            }, { passive: false });

            vp.addEventListener('touchstart', e => {
                if (e.touches.length === 2) {
                    isDragging = false;
                    initialPinchDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    initialScale = scale;
                } else if (e.touches.length === 1 && scale > 1) {
                    isDragging = true;
                    startX = e.touches[0].clientX - pX;
                    startY = e.touches[0].clientY - pY;
                }
                
                if (e.touches.length === 1) {
                    const now = new Date().getTime();
                    if (now - lastTapTime < 300) resetView();
                    lastTapTime = now;
                }
            }, { passive: false });

            vp.addEventListener('touchmove', e => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    if (initialPinchDistance > 0) {
                        scale = Math.min(Math.max(initialScale * (dist / initialPinchDistance), MIN_SCALE), MAX_SCALE);
                        applyTransform();
                    }
                } else if (isDragging && e.touches.length === 1) {
                    e.preventDefault();
                    pX = e.touches[0].clientX - startX;
                    pY = e.touches[0].clientY - startY;
                    requestAnimationFrame(applyTransform);
                }
            }, { passive: false });

            vp.addEventListener('touchend', e => {
                isDragging = false;
                if (e.touches.length === 0) initialPinchDistance = 0;
            });
        }

        init();
    </script>
</body>
</html>
